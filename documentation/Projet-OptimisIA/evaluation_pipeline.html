<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>Projet-OptimisIA.evaluation_pipeline API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Projet-OptimisIA.evaluation_pipeline</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Projet-OptimisIA.evaluation_pipeline.evaluation_pipeline"><code class="name flex">
<span>def <span class="ident">evaluation_pipeline</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluation_pipeline():
    &#34;&#34;&#34;The main function of the evaluation pipeline.

    This program takes as an input a single argument:
    - The path of an input file, which contains for each line a list of tones and a verbatim

    An example of input file can be found in &#34;generated_verbatims.txt&#34;

    The output will be given on the stdout. It will show metrics of all the prompt methods.
    &#34;&#34;&#34;
    if len(sys.argv)!=2:
        exit(f&#34;Usage: {sys.argv[0]} input_file.txt&#34;)

    categories = list(json.loads(file_to_str(&#34;categories.json&#34;)).keys())

    #for each classification method
    #for classification_method, name_of_method in zip([classify_zero_shot, classify_prompt_chaining, classify_tree_of_thoughts, classify_reflexion], [&#34;Zero-Shot&#34;, &#34;Prompt Chaining&#34;, &#34;Tree of Thoughts&#34;, &#34;Reflexion&#34;]):
    for classification_method, name_of_method in zip([classify_reflexion], [&#34;Reflexion&#34;]):
        time_taken = 0
        list_classified_tones = [[], []]
        nb_verbatims = 0
        
        #M is the &#34;resume table&#34;
        M = np.zeros((5, 4))

        #We classify and evaluate twice every verbatim to compute Krippendorff&#39;s alpha
        #We also use this opportunity to calculate twice all metrics
        for i in range(2):
            #For each verbatim and its gold standard (its real tones)
            for verbatim, tones in get_verbatims_and_tones(sys.argv[1]):
                print(&#34;classifying verbatim...&#34;)
                nb_verbatims += 1
                #We ask the LLM to classify according to the current classification method (while measuring the time)
                t0 = time(); classified_tones = classification_method(verbatim, categories); t1 = time()
                time_taken += t1 - t0
                #We store it (it will be useful to compute Krippendorff&#39;s alpha)
                list_classified_tones[i] += map(to_number, classified_tones)
                #We update the resume table (we count the number of true positives, false positives, true negatives, and false negatives)
                update_resume_table(M, classified_tones, tones)

        print(&#34;======&#34;)
        print_table(M)
        print(f&#34;Precision of {name_of_method}: {precision(M):.2f}&#34;)
        print(f&#34;Precision (bis) of {name_of_method}: {precision(M, bis=True):.2f}&#34;)
        print(f&#34;Recall of {name_of_method}: {recall(M):.2f}&#34;)
        print(f&#34;Recall (bis) of {name_of_method}: {recall(M, bis=True):.2f}&#34;)
        print(f&#34;Hallucination rate of {name_of_method}: {hallucination_rate(M):.2f}&#34;)
        print(f&#34;Krippendorff&#39;s alpha of {name_of_method}: {krippendorff.alpha(reliability_data=list_classified_tones, level_of_measurement=&#34;nominal&#34;):.2f}&#34;)
        print(f&#34;Time taken for {name_of_method}: {time_taken/(2*nb_verbatims):.2f}&#34;) #We divide by 2 since we classified everything twice</code></pre>
</details>
<div class="desc"><p>The main function of the evaluation pipeline.</p>
<p>This program takes as an input a single argument:
- The path of an input file, which contains for each line a list of tones and a verbatim</p>
<p>An example of input file can be found in "generated_verbatims.txt"</p>
<p>The output will be given on the stdout. It will show metrics of all the prompt methods.</p></div>
</dd>
<dt id="Projet-OptimisIA.evaluation_pipeline.get_verbatims_and_tones"><code class="name flex">
<span>def <span class="ident">get_verbatims_and_tones</span></span>(<span>filename: str) ‑> list[tuple[str, list[str]]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_verbatims_and_tones(filename : str) -&gt; list[tuple[str, list[str]]]:
    &#34;&#34;&#34;Returns a list of (verbatim, tones) which have previously been generated via verbatim-generator.py

    This function takes a filename as an input. TAn example of such filename is &#34;generated_verbatims.txt&#34;

    More precisions for the output:
    - verbatim is a string
    - tones is a list which, for the i-th category, contains a value between &#34;Positif&#34;, &#34;Négatif&#34;, &#34;Pas mentionné&#34;, and &#34;Neutre&#34;
    &#34;&#34;&#34;
    res = []
    with open(filename, &#34;r&#34;) as fd:
        for line in fd.readlines():
            #The verbatim is the right part of the line, just after the table of tones
            verbatim = line[line.index(&#34;]&#34;)+1:]
            #We transform the table of tones into a python table
            tones = json.loads(line[:line.index(&#34;]&#34;)+1])
            res.append((verbatim, tones))
    return res</code></pre>
</details>
<div class="desc"><p>Returns a list of (verbatim, tones) which have previously been generated via verbatim-generator.py</p>
<p>This function takes a filename as an input. TAn example of such filename is "generated_verbatims.txt"</p>
<p>More precisions for the output:
- verbatim is a string
- tones is a list which, for the i-th category, contains a value between "Positif", "Négatif", "Pas mentionné", and "Neutre"</p></div>
</dd>
<dt id="Projet-OptimisIA.evaluation_pipeline.hallucination_rate"><code class="name flex">
<span>def <span class="ident">hallucination_rate</span></span>(<span>M)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hallucination_rate(M):
    &#34;&#34;&#34;Returns the hallucination rate.
    
    The hallucination rate is equal to the number of false negatives of &#34;Pas mentionné&#34;,
    divided by the true positives, false positives, true negatives, and false negatives of &#34;Pas mentionné&#34;.

    Equivalently, it is the proportion of time where elements are wrongly not classified as &#34;Pas mentionné&#34;,
    which represents the rate at which the LLM sees features where there aren&#39;t.
    &#34;&#34;&#34;
    #hallucination_rate = ratio of tones which haven&#39;t been classified as &#34;Pas mentionné&#34; when they should
    #hallucination_rate = False Negatives of &#34;Pas mentionné&#34; / (True Positives of &#34;Pas Mentionné&#34; + ... + False Negatives of &#34;Pas Mentionné&#34;)
    return M[PAS_MENTIONNE][FN]/sum(M[PAS_MENTIONNE][i] for i in range(4))</code></pre>
</details>
<div class="desc"><p>Returns the hallucination rate.</p>
<p>The hallucination rate is equal to the number of false negatives of "Pas mentionné",
divided by the true positives, false positives, true negatives, and false negatives of "Pas mentionné".</p>
<p>Equivalently, it is the proportion of time where elements are wrongly not classified as "Pas mentionné",
which represents the rate at which the LLM sees features where there aren't.</p></div>
</dd>
<dt id="Projet-OptimisIA.evaluation_pipeline.mean"><code class="name flex">
<span>def <span class="ident">mean</span></span>(<span>x: list[int]) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean(x: list[int]) -&gt; float:
    &#34;&#34;&#34;Computes the mean of a list or generator&#34;&#34;&#34;
    x = list(x)
    return sum(x)/len(x) if len(x)!=0 else 0.5</code></pre>
</details>
<div class="desc"><p>Computes the mean of a list or generator</p></div>
</dd>
<dt id="Projet-OptimisIA.evaluation_pipeline.precision"><code class="name flex">
<span>def <span class="ident">precision</span></span>(<span>M, bis=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def precision(M, bis=False):
    &#34;&#34;&#34;Returns the precision.
    
    The precision is equal to mean(precision of &#34;Positif&#34;, ..., precision of &#34;Pas mentionné&#34;).
    The precision of the class i is the number of true positives of class i,
    divided by the number of true positives and false positives of class i.

    If bis=true, then the precision is the number of true positives of class &#34;Positif ou Négatif&#34;,
    divided by the number of true positives and false positives of class &#34;Positif ou Négatif&#34;

    If the division is impossible in any of these cases, we return -1.

    The second implementation is the method used in Zeno&#39;s article. In Zeno&#39;s article, they set
    &#34;Positif&#34; = &#34;Négatif&#34; = 1 and &#34;Neutre&#34; = &#34;Pas mentionné&#34; = 0, and compute the precision of the class 1.

    We include both methods since the first one has an advantage: as it considers &#34;Positif&#34; as different from
    &#34;Négatif&#34;, it penalizes a misclassification between these two classes, and the same can be said for the
    classes &#34;Neutre&#34; and &#34;Pas mentionné&#34;.
    &#34;&#34;&#34;
    if bis:
        #precision_bis = precision of class [&#34;Positif&#34;, &#34;Négatif&#34;]
        return -1 if (M[BIS][TP]+M[BIS][FP])==0 else M[BIS][TP]/(M[BIS][TP]+M[BIS][FP])
    else:
        #precision = mean(precision of &#34;Positif&#34;, ..., precision of &#34;Pas mentionné&#34;)
        #precision of class X = True Positives of class X / (True Positives of class X + False positives of class X)
        return -1 if any(M[i][TP]+M[i][FP]==0 for i in range(4)) else mean(M[i][TP]/(M[i][TP]+M[i][FP]) for i in range(4))</code></pre>
</details>
<div class="desc"><p>Returns the precision.</p>
<p>The precision is equal to mean(precision of "Positif", &hellip;, precision of "Pas mentionné").
The precision of the class i is the number of true positives of class i,
divided by the number of true positives and false positives of class i.</p>
<p>If bis=true, then the precision is the number of true positives of class "Positif ou Négatif",
divided by the number of true positives and false positives of class "Positif ou Négatif"</p>
<p>If the division is impossible in any of these cases, we return -1.</p>
<p>The second implementation is the method used in Zeno's article. In Zeno's article, they set
"Positif" = "Négatif" = 1 and "Neutre" = "Pas mentionné" = 0, and compute the precision of the class 1.</p>
<p>We include both methods since the first one has an advantage: as it considers "Positif" as different from
"Négatif", it penalizes a misclassification between these two classes, and the same can be said for the
classes "Neutre" and "Pas mentionné".</p></div>
</dd>
<dt id="Projet-OptimisIA.evaluation_pipeline.print_table"><code class="name flex">
<span>def <span class="ident">print_table</span></span>(<span>M)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_table(M):
    &#34;&#34;&#34;Prints the so-called &#34;resume table&#34; M.

    For more info about the resume table, see the documentation of update_resume_table().
    &#34;&#34;&#34;
    M = pandas.DataFrame(M, index=[&#34;Positif&#34;, &#34;Négatif&#34;, &#34;Neutre&#34;, &#34;Pas mentionné&#34;, &#34;Positif ou Négatif&#34;], columns=[&#34;True Positive&#34;, &#34;False Positive&#34;, &#34;True Negative&#34;, &#34;False Negative&#34;])
    print(M)</code></pre>
</details>
<div class="desc"><p>Prints the so-called "resume table" M.</p>
<p>For more info about the resume table, see the documentation of update_resume_table().</p></div>
</dd>
<dt id="Projet-OptimisIA.evaluation_pipeline.recall"><code class="name flex">
<span>def <span class="ident">recall</span></span>(<span>M, bis=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recall(M, bis=False):
    &#34;&#34;&#34;Returns the recall.
    
    The recall is equal to mean(recall of &#34;Positif&#34;, ..., recall of &#34;Pas mentionné&#34;).
    The recall of class i is the number of true positives of class i,
    divided by the number of true positives and false negatives of class i.

    If bis=true, then the recall is the number of true positives of class &#34;Positif ou Négatif&#34;,
    divided by the number of true positives and false negatives of class &#34;Positif ou Négatif&#34;

    If the division is impossible in any of these cases, we return -1.

    For more info about the bis option, see the documentation of precision().
    &#34;&#34;&#34;
    if bis:
        #recall_bis = recall of class [&#34;Positif&#34;, &#34;Négatif&#34;]
        return -1 if (M[BIS][TP]+M[BIS][FN])==0 else M[BIS][TP]/(M[BIS][TP]+M[BIS][FN])
    else:
        #recall = mean(recall of &#34;Positif&#34;, ..., recall of &#34;Pas mentionné&#34;)
        #recall of class X = True Positives of class X / (True Positives of class X + False Negatives of class X)
        return -1 if any((M[i][TP]+M[i][FN])==0 for i in range(4)) else mean(M[i][TP]/(M[i][TP]+M[i][FN]) for i in range(4))</code></pre>
</details>
<div class="desc"><p>Returns the recall.</p>
<p>The recall is equal to mean(recall of "Positif", &hellip;, recall of "Pas mentionné").
The recall of class i is the number of true positives of class i,
divided by the number of true positives and false negatives of class i.</p>
<p>If bis=true, then the recall is the number of true positives of class "Positif ou Négatif",
divided by the number of true positives and false negatives of class "Positif ou Négatif"</p>
<p>If the division is impossible in any of these cases, we return -1.</p>
<p>For more info about the bis option, see the documentation of precision().</p></div>
</dd>
<dt id="Projet-OptimisIA.evaluation_pipeline.to_number"><code class="name flex">
<span>def <span class="ident">to_number</span></span>(<span>s: str) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_number(s : str) -&gt; int:
    &#34;&#34;&#34;This function converts a tone into a number
    
    &#34;Positif&#34;       -&gt; 0
    &#34;Négatif&#34;       -&gt; 1
    &#34;Neutre&#34;        -&gt; 2
    &#34;Pas mentionné&#34; -&gt; 3
    &#34;&#34;&#34;
    return [&#34;Positif&#34;, &#34;Négatif&#34;, &#34;Neutre&#34;, &#34;Pas mentionné&#34;].index(s)</code></pre>
</details>
<div class="desc"><p>This function converts a tone into a number</p>
<p>"Positif"
-&gt; 0
"Négatif"
-&gt; 1
"Neutre"
-&gt; 2
"Pas mentionné" -&gt; 3</p></div>
</dd>
<dt id="Projet-OptimisIA.evaluation_pipeline.update_resume_table"><code class="name flex">
<span>def <span class="ident">update_resume_table</span></span>(<span>M: list[list[int]], classified_tones: list[str], actual_tones: list[str])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_resume_table(M : list[list[int]], classified_tones : list[str], actual_tones : list[str]):
    &#34;&#34;&#34;Updates the so-called &#34;resume table&#34; M.

    The resume table M is a matrix with five rows and four columns such that:
    - The five rows are named &#34;Positif&#34;, &#34;Négatif&#34;, &#34;Neutre&#34;, &#34;Pas mentionné&#34;, and &#34;Positif ou Négatif&#34;.
    - The four columns are named &#34;True Positive&#34;, &#34;False Positive&#34;, &#34;True Negative&#34;, &#34;False Negative&#34;
    - The intersection between (for instance) the column &#34;Neutre&#34; and &#34;False Positives&#34; is the number
    of false positives in the class &#34;Neutre&#34;, that is, the number of elements which have been classified
    as &#34;Neutre&#34; when they shouldn&#39;t.

    This function takes the resume table, a list of classified tones, and the actual tones,
    and updates the resume table accordingly. That is, for every class &#34;Positif&#34;, &#34;Négatif&#34;,
    &#34;Neutre&#34;, &#34;Pas Mentionné&#34;, and &#34;Positif ou Négatif&#34;, it counts the number of true positives,
    false positives, true negatives, and false negatives, and updates the row accordingly.    
    &#34;&#34;&#34;
    possible_tones = [[&#34;Positif&#34;], [&#34;Négatif&#34;], [&#34;Neutre&#34;], [&#34;Pas mentionné&#34;], [&#34;Positif&#34;, &#34;Négatif&#34;]]
    #For every row
    for i in range(len(possible_tones)):
        #We count the number of True Positives, False Positives, True Negatives, and False Negatives
        for actual_tone, classified_tone in zip(actual_tones, classified_tones):
            if classified_tone in possible_tones[i] and actual_tone in possible_tones[i]:
                M[i][TP] += 1
            elif classified_tone in possible_tones[i] and actual_tone not in possible_tones[i]:
                M[i][FP] += 1
            elif classified_tone not in possible_tones[i] and actual_tone not in possible_tones[i]:
                M[i][TN] += 1
            elif classified_tone not in possible_tones[i] and actual_tone in possible_tones[i]:
                M[i][FN] += 1</code></pre>
</details>
<div class="desc"><p>Updates the so-called "resume table" M.</p>
<p>The resume table M is a matrix with five rows and four columns such that:
- The five rows are named "Positif", "Négatif", "Neutre", "Pas mentionné", and "Positif ou Négatif".
- The four columns are named "True Positive", "False Positive", "True Negative", "False Negative"
- The intersection between (for instance) the column "Neutre" and "False Positives" is the number
of false positives in the class "Neutre", that is, the number of elements which have been classified
as "Neutre" when they shouldn't.</p>
<p>This function takes the resume table, a list of classified tones, and the actual tones,
and updates the resume table accordingly. That is, for every class "Positif", "Négatif",
"Neutre", "Pas Mentionné", and "Positif ou Négatif", it counts the number of true positives,
false positives, true negatives, and false negatives, and updates the row accordingly.</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Projet-OptimisIA" href="index.html">Projet-OptimisIA</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Projet-OptimisIA.evaluation_pipeline.evaluation_pipeline" href="#Projet-OptimisIA.evaluation_pipeline.evaluation_pipeline">evaluation_pipeline</a></code></li>
<li><code><a title="Projet-OptimisIA.evaluation_pipeline.get_verbatims_and_tones" href="#Projet-OptimisIA.evaluation_pipeline.get_verbatims_and_tones">get_verbatims_and_tones</a></code></li>
<li><code><a title="Projet-OptimisIA.evaluation_pipeline.hallucination_rate" href="#Projet-OptimisIA.evaluation_pipeline.hallucination_rate">hallucination_rate</a></code></li>
<li><code><a title="Projet-OptimisIA.evaluation_pipeline.mean" href="#Projet-OptimisIA.evaluation_pipeline.mean">mean</a></code></li>
<li><code><a title="Projet-OptimisIA.evaluation_pipeline.precision" href="#Projet-OptimisIA.evaluation_pipeline.precision">precision</a></code></li>
<li><code><a title="Projet-OptimisIA.evaluation_pipeline.print_table" href="#Projet-OptimisIA.evaluation_pipeline.print_table">print_table</a></code></li>
<li><code><a title="Projet-OptimisIA.evaluation_pipeline.recall" href="#Projet-OptimisIA.evaluation_pipeline.recall">recall</a></code></li>
<li><code><a title="Projet-OptimisIA.evaluation_pipeline.to_number" href="#Projet-OptimisIA.evaluation_pipeline.to_number">to_number</a></code></li>
<li><code><a title="Projet-OptimisIA.evaluation_pipeline.update_resume_table" href="#Projet-OptimisIA.evaluation_pipeline.update_resume_table">update_resume_table</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
